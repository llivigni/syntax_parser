/*
=============================================================================
Title       : parser.c
Description : A semantic analyzer to validate grammar
Author      : llivigni (R#11800181)
Date        : 11/20/2024
Version     : 1.0
Usage       : Compile and run this program using a makefile against
            the grading script on the HPCC.
Notes       : This program requires front.h and parser.h.
C Version   : GNU GCC
=============================================================================
*/

#include <stdio.h>
#include <stdlib.h>     /* For 'exit()' */

#include "parser.h"
#include "front.h"

/* Global Variables */
extern Token nextToken;

/* Local Function declaration */
static void error();
/******************************************************/
/* program
 * Parses strings in the language generated by the rule:
 * <P> -> <S>
 */
 void program()
 {
     statement();

     if (nextToken == EOF){
        printf("Syntax Validated.\n");
        exit(0);
     } else {
        error();
     }
 } /* End of function program */
/******************************************************/
/* statement
 * Parses strings in the language generated by the rule:
 * <S> -> V = E; S' | input(V); S' | output(E); S' | if(C){S} S' | if(C){S} else {S} S'
 */
void statement()
{
        /* V = E; S' */
        if(nextToken == IDENT){
            lex();
            if (nextToken == ASSIGN_OP){
                lex();
                expression();
                if (nextToken == SEMICOLON){
                    lex();
                    statement_prime();
                } else {
                    error();
                }
            } else {
                error();
            }
        /* input(V); S' */
        } else if (nextToken == KEY_IN){
            lex();
            if (nextToken == OPEN_PAREN){
                lex();
                if (nextToken == IDENT){
                    lex();
                    if (nextToken == CLOSE_PAREN){
                        lex();
                        if (nextToken == SEMICOLON){
                            lex();
                            statement_prime();
                    } else {
                        error();
                    }
                } else {
                    error();
                }
            } else {
                error();
            }
        } else {
            error();
        }
    /* output(E); S' */
    } else if (nextToken == KEY_OUT) {
            lex();
            if (nextToken == OPEN_PAREN){
                lex();
                expression();
                if (nextToken == CLOSE_PAREN){
                    lex();
                    if (nextToken == SEMICOLON){
                        lex();
                        statement_prime();
                    } else {
                        error();
                    }
                } else {
                    error();
                }
            } else {
                error();
            }
        /* if(C){S} S' */
        } else if (nextToken == KEY_IF) {
            lex();
            if (nextToken == OPEN_PAREN) {
                lex();
                condition();
                if (nextToken == CLOSE_PAREN) {
                    lex();
                    if (nextToken == OPEN_CURL) {
                        lex();
                        statement();
                        if (nextToken == CLOSE_CURL) {
                            lex();
                            if (nextToken == KEY_ELSE) {    /* ... else {S} S' */
                                lex();
                                if (nextToken == OPEN_CURL) {
                                    lex();
                                    statement();
                                    if (nextToken == CLOSE_CURL) {
                                        lex();
                                        statement_prime();
                                    } else {
                                        error();
                                    }
                                } else {
                                    error();
                                }
                            } else {
                                 statement_prime(); /* No else clause */
                            }
                        } else {
                            error();
                        }
                    } else {
                        error();
                    }
                } else {
                    error();
                }
            } else {
                error();
            }
        } else {
            error();
    }
} /* End of function statement */
/******************************************************/
/* statement_prime
 * Parses strings in the language generated by the rule:
 * <S> -> S S' | Epsilon
 */
 void statement_prime()
 {
     if (nextToken != EOF && nextToken != CLOSE_CURL){
        statement();
        statement_prime();
     }
    /* Epsilon */
 }/* End of function statement_prime */
/******************************************************/
/* condition
 * Parses strings in the language generated by the rule:
 * <C> -> E < E C' | E > E C' | E == E C' | E != E C' | E <= E C' | E >= E C' | !C C'
 */
void condition()
{
    expression();
    /* E < E C' | E > E C' | E == E C' | E != E C' | E <= E C' | E >= E C' */
    if (nextToken == LESSER_OP || nextToken == GREATER_OP || nextToken == EQUAL_OP
        || nextToken == NEQUAL_OP || nextToken == LEQUAL_OP || nextToken == GEQUAL_OP) {
            lex();
            expression();
            condition_prime();
        /* !C C' */
        } else if (nextToken == BOOL_NOT){
            lex();
            condition();
            condition_prime();
        } else {
            error();
        }
} /* End of function condition */
/******************************************************/
/* condition_prime
 * Parses strings in the language generated by the rule:
 * <C> -> && C C' | || C C' | Epsilon
 */
void condition_prime()
{
    /* && C C' */
    if (nextToken == BOOL_AND){
        lex();
        condition();
        condition_prime();
    /* || C C' */
    } else if (nextToken == BOOL_OR){
        lex();
        condition();
        condition_prime();
    }
    /* Epsilon */
} /* End of function condition_prime */
/******************************************************/
/* expression
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>} (EBNF)
 */
void expression()
{
    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }
} /* End of function expression */
/******************************************************/
/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | / | %) <factor>) (EBNF)
 */
void term()
{
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD_OP) {
            lex();
            factor();
    }
} /* End of function term */
/******************************************************/
/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> (E) | N | V
 * */
void factor()
{
    /* (E) */
    if (nextToken == OPEN_PAREN) {
        int parenLine = tokenLineNumber;        /* Store line number where opening paren occurs */
        lex();
        expression();
        if (nextToken == CLOSE_PAREN){
            lex();
        } else {
            tokenLineNumber = parenLine;            /* Use stored line number for error */
            error();
        }
    /* N | V */
    } else if (nextToken == INT_LIT || nextToken == IDENT){
        lex();
    } else {
        error();
    }/* End of else */
} /* End of function factor */
/******************************************************/
static void error()
{
    printf("Error encounter on line %d: The next lexeme was %s and the next token was ", tokenLineNumber, lexeme);

    if (nextToken == ASSIGN_OP){
        printf("ASSIGN_OP\n");
    } else if (nextToken == LESSER_OP){
        printf("LESSER_OP\n");
    } else if (nextToken == GREATER_OP){
        printf("GREATER_OP\n");
    } else if (nextToken == EQUAL_OP){
        printf("EQUAL_OP\n");
    } else if (nextToken == NEQUAL_OP){
        printf("NEQUAL_OP\n");
    } else if (nextToken == LEQUAL_OP){
        printf("LEQUAL_OP\n");
    } else if (nextToken == GEQUAL_OP){
        printf("GEQUAL_OP\n");
    } else if (nextToken == OPEN_PAREN){
        printf("OPEN_PAREN\n");
    } else if (nextToken == CLOSE_PAREN){
        printf("CLOSE_PAREN\n");
    } else if (nextToken == ADD_OP){
        printf("ADD_OP\n");
    } else if (nextToken == SUB_OP){
        printf("SUB_OP\n");
    } else if (nextToken == MULT_OP){
        printf("MULT_OP\n");
    } else if (nextToken == DIV_OP){
        printf("DIV_OP\n");
    } else if (nextToken == MOD_OP){
        printf("MOD_OP\n");
    } else if (nextToken == BOOL_AND){
        printf("BOOL_AND\n");
    } else if (nextToken == BOOL_OR){
        printf("BOOL_OR\n");
    } else if (nextToken == BOOL_NOT){
        printf("BOOL_NOT\n");
    } else if (nextToken == SEMICOLON){
        printf("SEMICOLON\n");
    } else if (nextToken == KEY_IN){
        printf("KEY_IN\n");
    } else if (nextToken == KEY_OUT){
        printf("KEY_OUT\n");
    } else if (nextToken == KEY_IF){
        printf("KEY_IF\n");
    } else if (nextToken == KEY_ELSE){
        printf("KEY_ELSE\n");
    } else if (nextToken == OPEN_CURL){
        printf("OPEN_CURL\n");
    } else if (nextToken == CLOSE_CURL){
        printf("CLOSE_CURL\n");
    } else if (nextToken == IDENT){
        printf("IDENT\n");
    } else if (nextToken == INT_LIT){
        printf("INT_LIT\n");
    } else {
        printf("UNKNOWN\n");
    }
    exit(1);
} /* End of function error */
